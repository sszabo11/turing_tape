; Unary multiplication: computes m × n where inputs are sequences of 1s separated by _
; Input format: 111_11 means 3 × 2, output will be 111111 (six 1s)
STATE_BEGIN
q0

INSTRUCTIONS
; q0: Initial state - skip to separator
q0 1 1 > q0
q0 0 0 > q0
q0 _ _ > q1
; q1: Find multiplier, position at first digit
q1 1 1 > q2
q1 0 0 > q1
q1 _ _ > halt-accept  ; Empty multiplier means done
; q2: At multiplier digit - if 1, prepare to copy multiplicand
q2 1 0 < q3  ; Mark this multiplier digit as used
q2 0 0 > q2  ; Skip already processed
q2 _ _ > halt-accept  ; All multiplier digits processed
; q3: Go back to separator
q3 1 1 < q3
q3 0 0 < q3
q3 _ _ < q4
; q4: Go back to start of multiplicand
q4 1 1 < q4
q4 0 0 < q4
q4 _ _ > q5
; q5: Copy multiplicand to end - scan multiplicand
q5 1 1 > q6
q5 0 0 > q5
q5 _ _ > q9  ; Done copying, go back to multiplier
; q6: Scan to end to write result digit
q6 1 1 > q6
q6 0 0 > q6
q6 _ _ > q7
; q7: Continue to result area
q7 1 1 > q7
q7 0 0 > q7
q7 _ 1 < q8  ; Write a 1 in result
; q8: Return to multiplicand
q8 1 1 < q8
q8 0 0 < q8
q8 _ _ > q5  ; Continue copying multiplicand
; q9: Done copying multiplicand once, return to multiplier
q9 1 1 > q9
q9 0 0 > q9
q9 _ _ > q1  ; Back to check next multiplier digit
halt-accept _ _ . halt-accept
halt-accept 1 1 . halt-accept
halt-accept 0 0 . halt-accept

MEMORY
= 1 1 1 _ 1 1
