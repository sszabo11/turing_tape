; Turing machine for unary multiplication: input 1^m 0 1^n  → halts with 1^{m*n} on the right side of tape
; Uses only 0,1,_ ; no extra symbols
; Head starts on leftmost symbol
; Example: 110111 (2×3) → should produce six 1's on right after process

STATE_BEGIN
q0

INSTRUCTIONS
; q0: start - skip over first group of 1's to find separator
q0 1 1 > q0
q0 0 0 > q_scan_second
q0 _ _ . halt-reject   ; no separator found

; q_scan_second: at separator - move to start of second number
q_scan_second 1 1 > q_find_end    ; has second number
q_scan_second 0 0 > q_scan_second ; skip extra 0 if any (robust)
q_scan_second _ _ < q_done        ; second empty → product 0, halt

; q_find_end: scan right to blank after second number
q_find_end 1 1 > q_find_end
q_find_end 0 0 > q_find_end       ; shouldn't happen but safe
q_find_end _ _ < q_append         ; now at blank - ready to append 1's

; q_append: append one 1 (simulate copying one from second group)
q_append _ 1 > q_shuttle_left     ; write 1, move right to prepare next or return
q_append 1 1 . halt-reject        ; shouldn't be here

; q_shuttle_left: go left back across result and second group to separator
q_shuttle_left 1 1 < q_shuttle_left
q_shuttle_left 0 0 < q_decide     ; reached separator → now decrement first

; q_decide: at separator - move left to find rightmost 1 in first group to erase
q_decide 0 0 < q_decide           ; skip processed 0's in first group
q_decide 1 0 > q_return           ; found rightmost 1 → erase to 0, go right (decrement done)
q_decide _ _ . halt-accept        ; no more 1's in first → multiplication complete!

; q_return: after decrement, scan right back to separator to repeat
q_return 0 0 > q_return
q_return 1 1 > q_return           ; skip remaining 1's in second/result
q_return _ _ < q0                 ; overshot? rare - but go left to restart scan

; q_done: final cleanup / halt (optional - move left over result or just halt)
q_done 1 1 < q_done
q_done 0 0 < q_done
q_done _ _ . halt-accept

; Fill in remaining combinations to prevent undefined behavior / loops
q0 0 0 > q_scan_second
q_scan_second _ _ < q_done
q_find_end _ _ < q_append
q_shuttle_left _ _ . halt-reject  ; shouldn't hit blank going left
q_decide 1 0 > q_return
q_return _ _ < q0

MEMORY
= 1 0 1
